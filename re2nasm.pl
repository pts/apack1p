#!/bin/sh --
eval 'PERL_BADLANG=x;export PERL_BADLANG;exec perl -x "$0" "$@";exit 1'
#!perl  # Start marker used by perl -x.
+0 if 0;eval("\n\n\n\n".<<'__END__');die$@if$@;__END__

#
# re2nasm.pl: converts RE32 i386 32-bit relocated executable image (generated by decimg.nasm) to NASM source file
# by pts@fazekas.hu at Sat Jan 25 00:50:51 CET 2025
#
# This script works with Perl 5.004.04 (1997-10-15) or later.
#

BEGIN { $ENV{LC_ALL} = "C" }  # For deterministic output. Typically not needed. Is it too late for Perl?
BEGIN { $ENV{TZ} = "GMT" }  # For deterministic output. Typically not needed. Perl respects it immediately.
BEGIN { $^W = 1 }  # Enable warnings.
use integer;
use strict;

die("Usage: $0 <filename.re32> <filename.syms> <outfilename.nasm>\n") if @ARGV != 3;
my $infn = $ARGV[0];
my $symsfn = $ARGV[1];  # Used as input.
my $outfn = $ARGV[2];
die("fatal: unsupported characters in filename: $infn\n") if $infn =~ m@[\0\r\n\\\x27]@;  # For NASM incbin.

sub fnopenq($) { $_[0] =~ m@[-+.\w]@ ? $_[0] : "./" . $_[0] }
sub read_file($) {
  my $fn = $_[0];
  die("fatal: open: $fn: $!\n") if !open(FR, "< " . fnopenq($fn));
  binmode(FR);
  my $s = join("", <FR>);
  die() if !close(FR);
  $s
}

$_ = read_file($infn);
die("fatal: file is not an RE32 i386 32-bit relocated executable\n") if length($_) < 0x20 or substr($_, 0, 4) ne "RE32";
my($signature, $entry_ofs, $bss_size, $text_size, $reloc_count, $data_size) = unpack("A4VVVVV", substr($_, 0, 0x20));
my $td_size = $text_size + $data_size;
my $text_fofs = 0x20;
my $data_fofs = $text_fofs + $text_size;
my $relocs_fofs = $data_fofs + $data_size;
my $after_relocs_fofs = $relocs_fofs + ($reloc_count << 2);
die("fatal: RE32 file too short: $infn\n") if length($_) < $after_relocs_fofs;
die("fatal: bad entry offset in RE32 file: $infn\n") if $entry_ofs >= $text_size;

# A list of [$eofs, $etype, $elabel] tuples. It will be extended in multiple steps below.
my @events = ([0, "0section", "text"], [$text_size, "0section", "data"], [$td_size, "0section", "bss"], [$td_size + $bss_size, "0section", "end"]);

my $last_reloc_ofs;
for (my $i = $relocs_fofs; $i < $after_relocs_fofs; $i += 4) {
  my $reloc_ofs = unpack("V", substr($_, $i, 4));
  die("fatal: bad relocation offset: $infn\n") if $reloc_ofs + 4 > $td_size;
  die("fatal: bad relocation order: $infn\n") if defined($last_reloc_ofs) and $reloc_ofs < $last_reloc_ofs + 4;
  push @events, [$reloc_ofs, "3reloc", ""];
}

sub check_get_ofs($$) {
  my($section, $addr) = @_;
  my $limit = ($section eq "bss") ? $bss_size : ($section eq "data") ? $data_size : ($section eq "text") ? $text_size : undef;
  die("fatal: bad seg: $section\n") if !defined($limit);
  die(sprintf("fatal: bad %s addr: 0x%x\n", $section, $addr)) if $addr > $limit;
  my $base = ($section eq "bss") ? $td_size : ($section eq "data") ? $text_size : ($section eq "text") ? 0 : undef;
  $base + $addr
}

my %regs32 = qw(eax 1 ebx 1 ecx 1 edx 1 esi 1 edi 1 ebp 1 esp 1);
my %labels;
my @ols;  # Each item is: [$ofs, $label]. Will be sorted.
my %has_label_at;
if (length($symsfn) and $symsfn ne ".") {
  die("fatal: open: $symsfn: $!\n") if !open(FS, "< " . fnopenq($symsfn));
  binmode(FS);
  local($_);
  while (<FS>) {
    if (m@^(\w+) equ _(text|data|bss)[+]0x([0-9a-f]+)$@) {
      my($label, $section, $addr) = ($1, $2, hex($3));
      my $ofs = check_get_ofs($section, $addr);
      push @events, [$ofs, "1label", $label];
      die("fatal: duplicate label: $label\n") if exists($labels{$label});
      $labels{$label} = $ofs;
      push @ols, [$ofs, $label];
      $has_label_at{$ofs} = 1 if $ofs == 0 or $ofs == $text_size or $ofs == $td_size;
    } elsif (m@^call_at _(text|data|bss)[+]0x([0-9a-f]+), (\w+)$@) {
      my($section, $addr, $label) = ($1, hex($2), $3);
      if (!exists($regs32{$label})) {
        if ($1 ne "text") { chomp; die("fatal: unexpected segment in syms line: $_\n") }
        push @events, [check_get_ofs($section, $addr), "2call", $label];
      }
    } elsif (m@^patch_db_at _(text|data|bss)[+]0x([0-9a-f]+), *([^,\s]+), *([^,\s]+)$@) {
      my($section, $addr, $old, $new) = ($1, hex($2), $3, $4);
      push @events, [check_get_ofs($section, $addr), "4patchdb", $old, $new];
    } else {
      chomp;
      die("fatal: syntax error in syms line: $_\n");
    }
  }
  die() if !close(FS);
}
push @events, [$entry_ofs, "1label", "_start"] if !exists($labels{"_start"});
push @events, [0, "1label", "_text"];
push @events, [$text_size, "1label", "_data"];
push @events, [$td_size, "1label", "_bss"];
push @ols, [0, "_text"] if !exists($has_label_at{0});
push @ols, [$text_size, "_data"] if !exists($has_label_at{$text_size});
push @ols, [$td_size, "_bss"] if !exists($has_label_at{$td_size});
# Sort by offset, then label.
@ols = sort { ($a->[0] <=> $b->[0]) or ($a->[1] cmp $b->[1]) } @ols;
# Sort by $eofs, "0section" first, then "1label" etc.
@events = sort { ($a->[0] <=> $b->[0]) or ($a->[1] cmp $b->[1]) or ($a->[2] cmp $b->[2]) } @events;

die("fatal: open for write: $outfn\n") if !open(FO, "> " . fnopenq($outfn));
binmode(FO);
sub wo { die("fatal: error writing to $outfn\n") if !print(FO @_) }

# OpenWatcom segments.
# section _TEXT  USE32 class=CODE align=1
# section CONST  USE32 class=DATA align=1  ; OpenWatcom generates align=4.
# section CONST2 USE32 class=DATA align=4
# section _DATA  USE32 class=DATA align=4
# section _BSS   USE32 class=BSS NOBITS align=4  ; NOBITS is ignored by NASM, but class=BSS works.
# group DGROUP CONST CONST2 _DATA _BSS
# section _TEXT
wo("; generated by re2nasm.pl\n\n",
   "bits 32\ncpu 386\n\n",
   "%ifidn __OUTPUT_FORMAT__, obj  ; OpenWatcom segments.\n",
   "  section _TEXT USE32 class=CODE align=4\n",
   "  section _DATA USE32 class=DATA align=4\n",
   "  section _BSS  USE32 class=BSS  align=4 NOBITS\n",
   "  group DGROUP _DATA _BSS\n",
   "%else\n",
     # Put .text first because of IDA.
   "  section .text align=4\n",
   "  section .data align=4\n",
   "  section .bss  align=4\n",
   "  %define _TEXT .text\n",
   "  %define _DATA .data\n",
   "  %define _BSS  .bss\n",
   "%endif\n",
   "section _TEXT\nglobal _start\n\n");  # Make subsequent exports go to _TEXT, to bad .obj.

# Returns the smallest index where to insert $ofs into list @ols, assuming
# @ols is sorted ->[0] numerically ascending.
#
# Based on bisect_right in python-2.7.17/Lib/bisect.py
sub bisect_left_ols($;$$) {
  my($ofs, $lo, $hi) = @_;
  $lo = 0 if !defined($lo);
  $hi = @ols if !defined($hi);
  die("fatal: assert: bad lo: $lo\n") if $lo < 0;
  die("fatal: assert: bad hi: $hi\n") if $hi > @ols;
  while ($lo < $hi) {
    my $mid = $lo + (($hi - $lo) >> 1);
    if ($ols[$mid][0] <= $ofs) { $lo = $mid + 1 }
    else { $hi = $mid }
  }
  $lo
}

sub get_label_spec($) {
  my $ofs = $_[0];
  # This returns segment-based: ($ofs >= $td_size) ? sprintf("\@_bss+0x%x", $ofs - $td_size) : ($ofs >= $text_size) ? sprintf("\@_data+0x%x", $ofs - $text_size) : sprintf("\@_text+0x%x", $ofs)
  my $i = bisect_left_ols($ofs);
  die("fatal: assert: ofs too small for ols: $ofs\n") if $i == 0;
  my($fofs, $flabel) = @{$ols[$i - 1]};
  sprintf("\@%s+0x%x", $flabel, $ofs - $fofs)
}

sub get_section_spec($) {
  my $ofs = $_[0];
  ($ofs >= $td_size) ? sprintf("\@_bss+0x%x", $ofs - $td_size) : ($ofs >= $text_size) ? sprintf("\@_data+0x%x", $ofs - $text_size) : sprintf("\@_text+0x%x", $ofs)
}

sub get_section_spec_end($) {
  my $ofs = $_[0];
  ($ofs > $td_size) ? sprintf("\@_bss+0x%x", $ofs - $td_size) : ($ofs > $text_size) ? sprintf("\@_data+0x%x", $ofs - $text_size) : sprintf("\@_text+0x%x", $ofs)
}

my $last_emit_ofs = 0;
sub emit($) {
  my $ofs = $_[0];
  die(sprintf("fatal: assert: bad last_emit_ofs: 0x%x should be <= 0x%x\n", $last_emit_ofs, $ofs)) if $last_emit_ofs > $ofs;
  if ($last_emit_ofs < $ofs) {
    my $at_spec = get_label_spec($last_emit_ofs);
    if ($last_emit_ofs >= $td_size) {
      wo(sprintf("resb 0x%x  ; %s\n", $ofs - $last_emit_ofs, $at_spec));
    } else {
      wo(sprintf("incbin '%s', 0x%x, 0x%x  ; %s\n", $infn, $text_fofs + $last_emit_ofs, $ofs - $last_emit_ofs, $at_spec));
    }
    $last_emit_ofs = $ofs;
  }
}

for my $event (@events) {
  my($eofs, $etype, $elabel) = @$event;
  #print STDERR "info: event: @$event\n";
  emit($eofs);
  if ($etype eq "0section") {
    wo(($elabel eq "data" or $elabel eq "bss" or $elabel eq "end") ? sprintf("; %s\n\n", get_section_spec_end($eofs)) : "");
    wo(($elabel eq "end") ? "; __END__\n" : "section _\U$elabel\E\n");
  } elsif ($etype eq "1label") {
    wo(sprintf("%s:  ; %s\n", $elabel, get_section_spec($eofs)));
  } elsif ($etype eq "2call") {
    wo(sprintf("call %s  ; %s\n", $elabel, get_label_spec($eofs)));  # TODO(pts): If label name is `eax', then prepend `$'.
    $last_emit_ofs += 5;
  } elsif ($etype eq "3reloc") {
    my $reloc_value_ofs = unpack("V", substr($_, $text_fofs + $eofs, 4));
    wo(sprintf("dd %s  ; %s\n", substr(get_label_spec($reloc_value_ofs), 1), get_label_spec($eofs)));
    $last_emit_ofs += 4;
  } elsif ($etype eq "4patchdb") {
    my($old, $new) = ($event->[2], $event->[3]);
    wo(sprintf("db %s  ; old db %s  ; %s\n", $new, $old, get_label_spec($eofs)));
    $last_emit_ofs += 1;
  } else {
    die("fatal: assert unknown event type: $etype\n");
  }
}

die("fatal: error flushing: $outfn\n") if !close(FO);

__END__
